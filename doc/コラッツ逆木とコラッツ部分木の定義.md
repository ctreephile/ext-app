# コラッツ逆木と部分木の定義（図解版・改訂）

本書は、拡張コラッツ設定 \(CTree(p, Q)\) における「コラッツ逆木」「根環」「接続ノード」「コラッツ部分木」を簡潔かつ一貫的に定義し、最小限の図解で直感を補います。

---

## 1. コラッツ逆木集合  CTree(p, Q)
- **CTree(p, Q)** とは、**1本以上のコラッツ逆木の和集合**である。
- 与えられたパラメータ **p** と **Q** によって一意に定まる。
- すべての自然数は、CTree(p, Q) に含まれるいずれかのコラッツ逆木に **ただ一度だけ** 現れる。

---

## 2. コラッツ逆木
- 各コラッツ逆木は、以下の2要素から構成される：
  1. **根環**（有限ループ状の巡回部分）
  2. **コラッツ部分木**（根環に接続して伸びる分岐構造）

---

## 3. 根環
- **根環**とは、拡張コラッツの逆アルゴリズムを辿ると **有限回で同じノードに戻る巡回部分**を指す。
- 各逆木には必ず根環が存在する。
- オリジナルのコラッツ（\(p=3,\ Q=[\_,1]\)）では根環は  
  \[\;1 \to 2 \to 4 \to 1\;\]

**図1：根環（例：1→2→4→1）と接続ノード 4**

<svg width="520" height="150" viewBox="0 0 520 150" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Collatz root cycle 1-2-4-1 with connection node 4 highlighted">
  <defs>
    <marker id="arrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
    <style>
      .node{fill:#fff;stroke:#333;stroke-width:1.5}
      .label{font-family:ui-sans-serif, system-ui; font-size:14px; dominant-baseline:middle; text-anchor:middle}
      .conn{stroke:#333;stroke-width:1.2;marker-end:url(#arrow)}
      .highlight{fill:#ffe8cc;stroke:#cc6f00;stroke-width:2}
      .caption{font-family:ui-sans-serif, system-ui; font-size:12px; fill:#444}
    </style>
  </defs>
  <!-- nodes -->
  <circle cx="120" cy="75" r="24" class="node"/>
  <text x="120" y="75" class="label">1</text>
  <circle cx="260" cy="75" r="24" class="node"/>
  <text x="260" y="75" class="label">2</text>
  <circle cx="400" cy="75" r="24" class="node highlight"/>
  <text x="400" y="75" class="label">4</text>
  <!-- arrows -->
  <path d="M 144 75 H 236" class="conn"/>
  <path d="M 284 75 H 376" class="conn"/>
  <path d="M 376 52 C 320 10, 200 10, 144 52" class="conn"/>
  <text x="400" y="120" class="caption">ハイライト = 接続ノード</text>
</svg>

---

## 4. 接続ノード
- **接続ノード**とは、根環に属しつつ、そこからコラッツ部分木が生える**分岐点**となるノードである。
- 接続ノードを 1 ステップ逆算して得られる値が、**部分木のルート**となる。

---

## 5. コラッツ部分木
- **コラッツ部分木**とは、**逆アルゴリズム**を適用して得られる数を樹状に配置した構造である。
- 部分木のルートは必ず接続ノードの**前駆**であり、通常は **\((p-1)\) の倍数**である。  
  **逆にいえば、拡張コラッツのアルゴリズムにより、部分木のルートを \((p-1)\) で割ることで、その数列は根環に突入するのである。**
- 部分木には **ループは含まれない**。  
  *理由*: 部分木は有限分岐の**木構造**を指すため、巡回が存在すると木の定義に反する。

**図2：接続ノード 4 と、部分木のルート 8（オリジナル設定）**

<svg width="560" height="220" viewBox="0 0 560 220" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Connection node 4 to subtree root 8 and first few reverse predecessors">
  <defs>
    <marker id="arrow2" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
    <style>
      .node{fill:#fff;stroke:#333;stroke-width:1.4}
      .label{font-family:ui-sans-serif, system-ui; font-size:13px; dominant-baseline:middle; text-anchor:middle}
      .edge{stroke:#333;stroke-width:1.1;marker-end:url(#arrow2)}
      .conn{fill:#ffe8cc;stroke:#cc6f00;stroke-width:2}
      .note{font-family:ui-sans-serif, system-ui; font-size:12px; fill:#444}
    </style>
  </defs>
  <!-- connection node on cycle -->
  <circle cx="80" cy="40" r="20" class="node conn"/>
  <text x="80" y="40" class="label">4</text>
  <text x="140" y="40" class="note">接続ノード（根環）</text>
  <!-- subtree root (predecessor of 4 under forward step) -->
  <path d="M 80 60 V 90" class="edge"/>
  <circle cx="80" cy="120" r="22" class="node"/>
  <text x="80" y="120" class="label">8</text>
  <text x="148" y="120" class="note">部分木のルート（8/2 = 4 で根環へ）</text>
  <!-- first reverse predecessors of 8 under reverse Collatz -->
  <path d="M 80 142 L 180 180" class="edge"/>
  <circle cx="200" cy="190" r="20" class="node"/>
  <text x="200" y="190" class="label">16</text>
  <text x="260" y="190" class="note">2×8 = 16</text>
  <!-- branching from 16 -->
  <path d="M 200 170 L 300 120" class="edge"/>
  <circle cx="320" cy="110" r="20" class="node"/>
  <text x="320" y="110" class="label">5</text>
  <text x="380" y="110" class="note">3×5+1=16</text>
  <path d="M 320 130 L 420 170" class="edge"/>
  <circle cx="440" cy="180" r="20" class="node"/>
  <text x="440" y="180" class="label">10</text>
  <text x="500" y="180" class="note">2×5 = 10</text>
</svg>

---

## 6. Q の与え方（一般化）
- **Q** は長さ \((p-1)\) の配列で、**各剰余クラス** \(i \in \{0,1,\dots,p-2\}\) に対し、逆写像の加算項を指定する。
- 具体的には、ノード値 \(n\) を \((p-1)\) で割った余り \(i\) に対して、
  \[\; n \mapsto p\,n + Q[i] \;]\
  を逆方向の生成規則とする（定義されない場合は欠番記号 \(_\) を用いる）。
- **記法**：`_` はその剰余に対応する逆写像が**存在しない**ことを示す。

---

## 7. 例：オリジナル・コラッツ
- **CTree( p = 3, Q = [\_, 1] )**
  - この場合、CTree にはコラッツ逆木が **1本だけ** 存在する。
  - **根環**：1 → 2 → 4 → 1
  - **接続ノード**：4
  - **部分木**：ルート 8 を持ち、逆算により枝分かれしていく（図2参照）。

---

## 8. 抽象図：一般の \(CTree(p,Q)\)
**図3：複数の接続ノードと複数の部分木がぶら下がる一般形**

<svg width="680" height="260" viewBox="0 0 680 260" xmlns="http://www.w3.org/2000/svg" role="img" aria-label="Abstract generalized CTree(p,Q) with root cycle and multiple attachment points">
  <defs>
    <marker id="arrow3" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
      <path d="M 0 0 L 10 5 L 0 10 z" />
    </marker>
    <style>
      .node{fill:#fff;stroke:#333;stroke-width:1.4}
      .label{font-family:ui-sans-serif, system-ui; font-size:12px; dominant-baseline:middle; text-anchor:middle}
      .edge{stroke:#333;stroke-width:1.1;marker-end:url(#arrow3)}
      .conn{fill:#e6f4ff;stroke:#1d65a6;stroke-width:2}
      .root{fill:#fef9c3;stroke:#a16207;stroke-width:2}
      .hint{font-family:ui-sans-serif, system-ui; font-size:12px; fill:#444}
    </style>
  </defs>
  <!-- root cycle as 6-node loop -->
  <circle cx="140" cy="80" r="20" class="node"/>
  <text x="140" y="80" class="label">r1</text>
  <circle cx="240" cy="60" r="20" class="node conn"/>
  <text x="240" y="60" class="label">r2*</text>
  <circle cx="340" cy="80" r="20" class="node"/>
  <text x="340" y="80" class="label">r3</text>
  <circle cx="420" cy="120" r="20" class="node conn"/>
  <text x="420" y="120" class="label">r4*</text>
  <circle cx="320" cy="150" r="20" class="node"/>
  <text x="320" y="150" class="label">r5</text>
  <circle cx="200" cy="140" r="20" class="node"/>
  <text x="200" y="140" class="label">r6</text>
  <!-- cycle arrows -->
  <path d="M 160 76 L 220 64" class="edge"/>
  <path d="M 260 68 L 320 76" class="edge"/>
  <path d="M 360 90 L 402 110" class="edge"/>
  <path d="M 406 140 L 336 146" class="edge"/>
  <path d="M 300 148 L 220 138" class="edge"/>
  <path d="M 186 124 L 132 86" class="edge"/>
  <text x="500" y="48" class="hint">* = 接続ノード</text>

  <!-- subtree roots hanging from connection nodes -->
  <path d="M 240 80 V 110" class="edge"/>
  <circle cx="240" cy="130" r="22" class="node root"/>
  <text x="240" y="130" class="label">(p-1)k</text>
  <text x="240" y="158" class="hint">割ると r2* へ</text>

  <path d="M 420 140 V 170" class="edge"/>
  <circle cx="420" cy="190" r="22" class="node root"/>
  <text x="420" y="190" class="label">(p-1)ℓ</text>
  <text x="420" y="218" class="hint">割ると r4* へ</text>
</svg>

---

## 9. 参考：実装・検証用の補足（任意）
- **部分木ルート判定**：候補 \(x\) が \((p-1)\) の倍数で、\(x/(p-1)\) が接続ノードに一致する。
- **重複排除**：生成済みノード集合に対するユニーク性チェックにより、CTree(p,Q) 内での一意出現を担保する。
- **Q の安全性**：Q の選び方により収束性や巡回構造が変化する。目的に応じて設計・検証すること。

---

以上。図はあくまで模式図であり、正確な枝の全展開を意図していません（プログラムによる自動生成図と併用してください）。


   